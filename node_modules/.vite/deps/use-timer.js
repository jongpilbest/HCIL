import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// node_modules/use-timer/lib/state/reducer.js
var require_reducer = __commonJS({
  "node_modules/use-timer/lib/state/reducer.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    function reducer(state, action) {
      switch (action.type) {
        case "advanceTime": {
          var timeToAdd = action.payload.timeToAdd;
          return __assign(__assign({}, state), { time: state.timerType === "DECREMENTAL" ? state.time - timeToAdd : state.time + timeToAdd });
        }
        case "pause": {
          return __assign(__assign({}, state), { status: "PAUSED" });
        }
        case "reset": {
          return __assign(__assign({}, state), { status: "STOPPED", time: action.payload.initialTime });
        }
        case "set": {
          return __assign(__assign({}, state), { time: action.payload.newTime });
        }
        case "start": {
          var initialTime = action.payload.initialTime;
          return __assign(__assign({}, state), { status: "RUNNING", time: state.status === "STOPPED" ? initialTime : state.time });
        }
        case "stop": {
          return __assign(__assign({}, state), { status: "STOPPED" });
        }
        default:
          return state;
      }
    }
    exports.default = reducer;
  }
});

// node_modules/use-timer/lib/useTimer.js
var require_useTimer = __commonJS({
  "node_modules/use-timer/lib/useTimer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTimer = void 0;
    var react_1 = require_react();
    var reducer_1 = __importDefault(require_reducer());
    exports.useTimer = function(_a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.autostart, autostart = _c === void 0 ? false : _c, endTime = _b.endTime, _d = _b.initialTime, initialTime = _d === void 0 ? 0 : _d, _e = _b.interval, interval = _e === void 0 ? 1e3 : _e, onTimeOver = _b.onTimeOver, onTimeUpdate = _b.onTimeUpdate, _f = _b.step, step = _f === void 0 ? 1 : _f, _g = _b.timerType, timerType = _g === void 0 ? "INCREMENTAL" : _g;
      var _h = react_1.useReducer(reducer_1.default, {
        status: "STOPPED",
        time: initialTime,
        timerType
      }), state = _h[0], dispatch = _h[1];
      var status = state.status, time = state.time;
      var advanceTime = react_1.useCallback(function(timeToAdd) {
        dispatch({ type: "advanceTime", payload: { timeToAdd } });
      }, []);
      var pause = react_1.useCallback(function() {
        dispatch({ type: "pause" });
      }, []);
      var reset = react_1.useCallback(function() {
        dispatch({ type: "reset", payload: { initialTime } });
      }, [initialTime]);
      var start = react_1.useCallback(function() {
        dispatch({ type: "start", payload: { initialTime } });
      }, []);
      react_1.useEffect(function() {
        if (autostart) {
          dispatch({ type: "start", payload: { initialTime } });
        }
      }, [autostart]);
      react_1.useEffect(function() {
        if (typeof onTimeUpdate === "function") {
          onTimeUpdate(time);
        }
      }, [time]);
      react_1.useEffect(function() {
        if (status !== "STOPPED" && time === endTime) {
          dispatch({ type: "stop" });
          if (typeof onTimeOver === "function") {
            onTimeOver();
          }
        }
      }, [endTime, onTimeOver, time, status]);
      react_1.useEffect(function() {
        var intervalId = null;
        if (status === "RUNNING") {
          intervalId = setInterval(function() {
            dispatch({
              type: "set",
              payload: {
                newTime: timerType === "DECREMENTAL" ? time - step : time + step
              }
            });
          }, interval);
        } else if (intervalId) {
          clearInterval(intervalId);
        }
        return function() {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
      }, [status, step, timerType, interval, time]);
      return { advanceTime, pause, reset, start, status, time };
    };
  }
});

// node_modules/use-timer/lib/index.js
var require_lib = __commonJS({
  "node_modules/use-timer/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTimer = void 0;
    var useTimer_1 = require_useTimer();
    Object.defineProperty(exports, "useTimer", { enumerable: true, get: function() {
      return useTimer_1.useTimer;
    } });
  }
});
export default require_lib();
//# sourceMappingURL=use-timer.js.map
